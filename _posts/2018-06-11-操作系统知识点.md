---
layout: post
title: '操作系统知识点'
subtitle: '找工作面试'
date: 2018-06-11
categories: 操作系统
tags: 操作系统 
---

# 操作系统知识点
----------

#### 1. 什么是缓存一致性问题？怎么解决
当程序在运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中，那么 CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。

在多核 CPU 中，每条线程可能运行于不同的 CPU 中，因此每个线程运行时有自己的高速缓存。比如 **i=i+1**, 我们希望**i=0**在两个线程执行完后，**i**的值为**2**，但存在这种情况：初始时，两个线程从主存分别读取**i=0**至各自的告诉缓存，更新后为**1**，也就是说， 如果一个变量在多个 CPU 中都存在缓存（一般在多线程编程时才会出现） ， 那么就可能存在缓存不一致的问题。

2种解决方法：
- 通过在总线加 LOCK#锁的方式：因为 CPU 和其他部件进行通信都是通过总线来进行的， 如果对总线加 LOCK#锁的话， 也就是说阻塞了其他 CPU 对其他部件访问（如内存），这种方式在锁住期间，其他CPU无法访问内存，效率低下；
- 通过缓存一致性协议：该协议保证了每个缓存中使用的共享变量的副本是一致的。 它核心的思想是： 当 CPU 向内存写入数据时， 如果发现操作的变量是共享变量， 即在其他 CPU 中也存在该变量的副本， 会发出信号通知其他 CPU 将该变量的缓存行置为无效状态， 因此当其他 CPU 需要读取这个变量时， 发现自己缓存中缓存该变量的缓存行是无效的， 那么它就会从内存重新读取。

#### 2. 简述 volatile 关键字
一旦一个**共享变量**（类的成员变量、 类的静态成员变量） 被 volatile 修饰之后， 那么就具备了两层语义：
- 保证了不同线程对这个变量进行读取时的可见性， 即一个线程修改了某个变量的值， 这新值对其他线程来说是立即可见的。 (volatile 解决了线程间共享变量的可见性问题)。
- 禁止进行指令重排序， 阻止编译器对代码的优化：
1. 当程序执行到 volatile 变量的读操作或者写操作时， 在其前面的操作的更改肯定全部已经进行， 且结果已经对后面的操作可见； 在其后面的操作肯定还没有进行；
2. 在进行指令优化时， 不能把 volatile 变量前面的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。（内存屏障）

#### 3. 线程基本概念，状态，与状态之间的关系
线程，有时称为轻量级进程，是CPU使用的基本单元；它由线程ID、程序计数器、寄存器集合和堆栈组成。它与属于同一进程的其他线程共享其代码段、数据段和其他操作系统资源（如打开文件和信号）。

线程有四种状态：**新生状态**、**可运行状态**、**被阻塞状态**、**死亡状态**。
![状态跳转图 | 500x500](http://static.oschina.net/uploads/space/2013/1230/163922_UEm6_1426828.jpg)

#### 4. 线程与进程的区别？
-  线程是进程的一部分，是进程中的实体，一个程序至少有一个进程，一个进程至少有一个线程；
-  进程在执行过程中拥有独立的内存单元，而多个线程共享进程所拥有的内存；
-  线程是处理器调度的基本单位，而进程是操作系统资源调度的基本单元；
-  进程可以独立运行，但线程不能够独立执行，必须依存在进程中，由使用该进程的应用程序提供多个线程执行控制。

#### 5. 多线程有几种实现方法？
- 继承 **Thread** 类
- 实现 **Runnable** 接口再 **new Thread(YourRunnableOjbect)** 

#### 6. 多线程同步和互斥有几种实现方法？
- 多线程同步有如下几种实现方法：**事件**、**信号量**
- 多线程互斥有如下几种实现方法：**临界区**、**事件**、**信号量**、**互斥量**
- **临界区**：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；一段连续的代码，它要求在执行前获得对某些共享数据的独占访问权。
- **事件（Event）**：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。
- **信号量**：为控制一个具有有限数量用户资源而设计，计数器。
- **互斥量（Mutex）**：为协调共同对一个共享资源的单独访问而设计的，同一个时刻只允许一个线程访问一个变量。

#### 7. 多线程同步和互斥有何异同？
互斥是一种特殊的同步。当访问资源量存在先后的顺序的时候使用同步，当需要独占试访问资源时使用互斥。如，一个生产者和多个消费者之间。生产者和消费者之间是同步关系；消费者之间是互斥关系。

#### 8. 进程间通信（IPC）
- 管道：半双工，只能用于具有亲缘关系的进程（父子进程或兄弟进程），看成一个特殊的文件，可读写，存在于内存中。
- FIFO命名管道：无关的进程之间交换数据，FIFO有路径名与之关联，以一种特别设备文件形式存在于文件系统中。
- 消息对列：消息的链接表，存放在内核中。一个消息对列由一个标识符（即对列ID）来标识。
- 信号量：计数器，用于实现进程间的互斥与同步。
- 共享内存：两个或多个进程共享一个给定的储存区，需要进行同步。
- Socket：可用于不同机器间的通信。

#### 9. 死锁以及解决，避免方法
- **死锁概念**：多个线程由于资源竞争长期阻塞，导致无法释放资源的现象。
- **死锁条件**：
1. 互斥条件：资源不能被共享，只能由一个进程使用；
2. 请求与保持条件：进程已获得了一些资源，但因请求其它资源被阻塞时，对已获得的资源保持不放。
3. 不可抢占条件：有些系统资源是不可抢占的，当某个进程已获得这种资源后，系统不能强行收回，只能由进程使用完时自己释放。
4. 循环等待条件：若干个进程形成环形链，每个都占用对方申请的下一个资源。
- **处理死锁的策略**：
1. 忽略该问题。例如**鸵鸟算法**。
2. 检测死锁并且恢复。
3. 仔细地对资源进行动态分配，以避免死锁。
4.  通过破除死锁四个必要条件之一，来防止死锁产生。
- **死锁的避免**：系统动态的确定是否分配一个资源给请求的进程
1. 如果一个进程的当前请求的资源会导致死锁，系统拒绝启动该进程；
2. 如果一个资源的分配会导致下一步的死锁，系统就拒绝本次的分配；
- **解决死锁的策略**：
死锁预防，死锁避免，死锁检测，死锁解除。
- **银行家算法**
是指在分配资源之前先看清楚，资源分配后是否会导致系统死锁。如果会死锁，则不分配，否则就分配。