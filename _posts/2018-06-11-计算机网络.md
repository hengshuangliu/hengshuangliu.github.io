---
layout: post
title: 计算机网络
description: 面试中计算机网络相关问题
categories: 计算机网络
keywords: 计算机网络, 面试
---

面试中计算机网络相关问题

#计算机网络
----------
#### 1. OSI与TCP/IP各层结构与功能、协议
 ![osi参考模型](/images/posts/20180612/1506134575239.png)
- **物理层**：定义了为建立、 维护和拆除物理链路所需的机械的、 电气的、功能的和规程的特性， 其作用是使原始的数据比特流能在物理媒体上传输；（**RJ45、 CLOCK、 IEEE802.3**）
- **数据链路层**：比特流被组织成数据链路协议数据单元(通常称为帧)， 并以其为单位进行传输， 帧中包含地址、 控制、 数据及校验码等信息。数据链路层的主要作用是通过校验、 确认和反馈重发等手段， **将不可靠的物理链路改造成对网络层来说无差错的数据链路**。（**PPP、 FR、 HDLC、 VLAN、 MAC**）
- **网络层**：数据以网络协议数据单元(分组)为单位进行传输。 网络层关心的是通信子网的运行控制， 主要解决如何使数据分组跨越通信子网从源传送到目的地的问题， 这就需要在通信子网中进行**路由选择**。（**IP、 ICMP、 ARP、 RARP、 OSPF、 IPX、 RIP、 IGMP**）
- **传输层**：是第一个端--端， 也即**主机--主机**的层次。 传输层提供的端到端的透明数据运输服务， 使高层用户不必关心通信子网的存在， 由此用统一的运输原语书写的高层软件便可运行于任何通信子网上。（**TCP、 UDP、 SPX**）
- **会话层**：是**进程--进程**的层次， 其主要功能是组织和同步不同的主机上各种进程间的通信(也称为对话)。 会话层负责在两个会话层实体之间进行对话连接的建立和拆除。（**RPC、 SQL、 NETBIOS、 NFS**）
- **表示层**：为上层用户提供共同的数据或信息的语法表示变换。表示层管理这些抽象的数据结构， 并将计算机内部的表示形式转换成网络通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的表示变换功能。（**JPEG、 MPEG、 ASCII、 MIDI**）
- **应用层**：不同的应用层为特定类型的网络应用提供访问 OSI 环境的手段。（**RIP、 BGP、 FTP、 DNS、 Telnet、 SMTP、 HTTP、 WWW、 NFS**）

#### 2. IP地址的分类
![IP地址分类](/images/posts/20180612/1506137371947.png)

#### 3. TCP/IP连接三次握手和四次分手
![图解](/images/posts/20180612/1506138208442.png)
- 3次握手过程状态变化：
1. **LISTEN**：表示服务器端的某个 SOCKET 处于监听状态， 可以接受连接了。
2. **SYN_SENT**：当客户端 SOCKET 执行 CONNECT 连接时， 它首先发送 SYN 报文， 因此也随即它会进入到了 SYN_SENT 状态， 并等待服务端发送三次握手中的第 2 个报文。SYN_SENT 状态表示客户端已发送 SYN 报文。
3. **SYN_RCVD**：这个状态表示接收到了 SYN 报文， 在正常情况下， 这个状态是服务器端的 SOCKET 在建立 TCP 连接时的三次握手会话过程中的一个中间状态， 很短暂， 基本上用 netstat 你是很难看到这种状的；
4. **ESTABLISHED**： 表示连接已经建立了。
- 4 次挥手过程状态：
1. **FIN_WAIT_1**：当 SOCKET 在 ESTABLISHED 状态时， 它想主动关闭连接， 向对方发送了 FIN 报文，此时该 SOCKET 即进入到 FIN_WAIT_1 状态。 
2. **FIN_WAIT_2**：实际上 FIN_WAIT_2 状态下的 SOCKET，表示半连接， 也即有一方要求 close 连接， 但另外还告诉对方， 我暂时还有点数据需要传送给你(ACK 信息)， 稍后再关闭连接。
3. **TIME_WAIT**：表示收到了对方的FIN报文， 并发送出了ACK报文， 就等2MSL后即可回到CLOSED可用状态了。如果 FIN_WAIT_1 状态下， 收到了对方同时带 FIN 标志和 ACK标志的报文时， 可以直接进入到TIME_WAIT 状态， 而无须经过 FIN_WAIT_2 状态。
4. **CLOSING**：表示双方同时关闭连接。 如果双方几乎同时调用 close 函数，那么会出现双方同时发送 FIN 报文的情况， 就会出现 CLOSING 状态， 表示双方都在关闭连接。（**较少见**）
5. **CLOSE_WAIT**： CLOSE_WAIT 状态下， 需要完成的事情是等待你去关闭连接。（**被动方的状态**）
6. **LAST_ACK**：它是被动关闭一方在发送 FIN 报文后，最后等待对方的 ACK 报文。
7. **CLOSED**：表示连接中断。
**netstat** 查看 TCP 状态值

#### 4. 为什么收到 Server 端的确认之后， Client 还需要进行第三次“握手” 呢？
- 采用三次握手是为了**防止失效的连接请求报文段**突然又传送到主机，因而发生错误；
- **已失效的连接请求报文段**的产生在这样一种情况下： client 发出的第一个连接请求报文段并没有丢失， 而是在某个网络结点长时间的滞留了（因为网络并发量很大在某结点被阻塞了），以致延误到连接释放以后的某个时间才到达 server。
- 若不采用第三次握手，则server端认为该失效的连接请求连接成功，等待client端数据到来，server端一直浪费资源。

#### 5.为什么要 4 次挥手？
- 确保数据能够完成传输。
- TCP是**全双工**模式，确保两方数据都传输完毕才关闭连接，故这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。

#### 6. 建立连接的第二个 syn 作用
- 因为客户端发送的 syn 可能过了好久才到达服务端， 而此时客户端超时重传的 SYN 已经到达服务端， 那么后来的 SYN 就是无效的， 如果不发第二个 syn 查询客户端是否有效的话， 服务端就会监听这个延迟到达的请求， 造成资源的浪费。 所以可以强制发送一个 SYN询问客户端之前的请求是否有效。

#### 7. time_wait 状态产生的原因
1. **可靠地实现 TCP 全双工连接的终止**：假想网络是不可靠的， 你无法保证你最后发送的 ACK 报文会一定被对方收到， 因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文， 而重发 FIN报文；当客户 端等待 2MSL（ 2倍报文最大生存时间） 后， 没有收到服务端的 FIN 报文后， 他就知道服务端已收到了 ACK报文， 所以客户端此时才关闭自 己的连接。
2. **允许老的重复分节在网络中消逝**：如果 TIME_WAIT 状态保持时间不足够长 ( 比如小于 2MSL) ， 第一个连接就正常终止
了。 第二个拥有相同四元组(local_ip, local_port, remote_ip, remote_port) 的连接出现（建立起一个相同的 IP 地址和端口之间的 TCP 连接） ， 而第一个连接的重复报文到达，干扰了第二个连接。

#### 8. TIME_WAIT 的时间
就是 2 个报文最长生存时间（**2MSL**） ， 1 个 MSL 在 RFC 上建议是 2 分钟， 而实现传统上
使用 30 秒， 因而， TIME_WAIT 状态一般维持在 1-4 分钟。

#### 9. 关闭连接最后一个ACK丢失
如果最后一个 ACK 丢失的话， TCP 就会认为它的 FIN 丢失， 进行重发 FIN。在客户端收到 FIN 后， 就会设置一个 2MSL 计时器， 2MSL 计时器可以使客户等待足够长的时间， 使得在 ACK 丢失的情况下， 可以等到下一个 FIN 的到来。 如果在 TIME－ WAIT 状态汇总有一个新的 FIN 到达了， 客户就会发送一个新的 ACK，并重新设置 2MSL 计时器。