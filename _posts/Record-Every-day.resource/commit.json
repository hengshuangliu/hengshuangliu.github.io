{"compress":true,"commitItems":[["d323d6bd-e9c2-4423-becd-795256279a8f",1536386744823,"",[[1536386742742,["hsliu5@hsliu5",[[1,0,"---\nlayout: post\ntitle: 学会gdb的使用\ncategories: linux\ndescription: 学会在linux下使用gdb调试代码\nkeywords: linux, Debug，gdb\n---\n工欲善其事，必先利其器。gdb作为一个高效的debug工具，必学之！\n\n## \n\n## 后话\nBug是程序猿最不愿见到的，掌握了gdb，就再也不怕bug啦！\n\n## 参考\n* <http://www.yolinux.com/TUTORIALS/GDB-Commands.html>"]],[0,0],[254,254]]],[1536386754739,["hsliu5@hsliu5",[[-1,155,"## 后话\nBug是程序猿最不愿见到的，掌握了gdb，就再也不怕bug啦！"]],[155,192],[155,155]]],[1536386755051,["hsliu5@hsliu5",[[-1,156,"\n"]],[155,155],[154,154]]],[1536386755260,["hsliu5@hsliu5",[[-1,155,"\n"]],[154,154],[153,153]]],[1536386760234,["hsliu5@hsliu5",[[-1,0,"---\nlayout: post\ntitle: 学会gdb的使用\ncategories: linux\ndescription: 学会在linux下使用gdb调试代码\nkeywords: linux, Debug，gdb\n---"]],[0,113],[0,0]]],[1536386762645,["hsliu5@hsliu5",[[-1,0,"\n"]],[1,1],[0,0]]],[1536386767671,["hsliu5@hsliu5",[[-1,0,"工欲善其事，必先利其器。gdb作为一个高效的debug工具，必学之"]],[0,33],[0,0]]],[1536386779950,["hsliu5@hsliu5",[[1,0,"每天积累一点，加油"]],[0,0],[9,9]]],[1536386791040,["hsliu5@hsliu5",[[1,15,"C++"]],[15,15],[18,18]]],[1536386791062,["hsliu5@hsliu5",[[1,18,"++"]],[18,18],[18,18]]],[1536386792024,["hsliu5@hsliu5",[[-1,16,"++"]],[18,18],[16,16]]],[1536386793674,["hsliu5@hsliu5",[[1,18,"ZHI"]],[18,18],[21,21]]],[1536386794632,["hsliu5@hsliu5",[[-1,18,"ZHI"]],[21,21],[18,18]]],[1536386796022,["hsliu5@hsliu5",[[1,18,"zhizh"]],[18,18],[23,23]]],[1536386797082,["hsliu5@hsliu5",[[-1,18,"zhizh"]],[23,23],[18,18]]],[1536386801170,["hsliu5@hsliu5",[[1,18,"指针问题"]],[18,18],[22,22]]],[1536386802070,["hsliu5@hsliu5",[[-1,20,"问题"]],[22,22],[20,20]]],[1536386817584,["hsliu5@hsliu5",[[1,20,"f"]],[18,20],[20,21]]],[1536386820089,["hsliu5@hsliu5",[[1,21,"ree时"]],[20,20],[25,25]]],[1536386820726,["hsliu5@hsliu5",[[-1,24,"时"]],[25,25],[24,24]]],[1536386822888,["hsliu5@hsliu5",[[1,24,"是"]],[24,24],[25,25]]],[1536386830974,["hsliu5@hsliu5",[[1,25,"如何知道内存块大小的？"]],[25,25],[36,36]]],[1536386831475,["hsliu5@hsliu5",[[1,38,"\n"]],[36,36],[37,37]]],[1536387234807,["hsliu5@hsliu5",[[1,37,"···"]],[37,37],[40,40]]],[1536387235975,["hsliu5@hsliu5",[[-1,37,"···"]],[40,40],[37,37]]],[1536387236990,["hsliu5@hsliu5",[[1,37,"```"]],[37,37],[40,40]]],[1536387237013,["hsliu5@hsliu5",[[1,40,"language\n```\n"]],[40,40],[40,48]]],[1536387241889,["hsliu5@hsliu5",[[-1,40,"language"],[1,48,"cplusplus"]],[40,48],[49,49]]],[1536387244536,["hsliu5@hsliu5",[[-1,41,"plusplus"]],[49,49],[41,41]]],[1536387246369,["hsliu5@hsliu5",[[1,41,"++"]],[41,41],[43,43]]],[1536387246391,["hsliu5@hsliu5",[[1,43,"++"]],[43,43],[43,43]]],[1536387247217,["hsliu5@hsliu5",[[-1,41,"++"]],[43,43],[41,41]]],[1536387249161,["hsliu5@hsliu5",[[-1,41,"++"]],[43,43],[41,41]]],[1536387250289,["hsliu5@hsliu5",[[1,41,"plu"]],[41,41],[44,44]]],[1536387251016,["hsliu5@hsliu5",[[-1,42,"lu"]],[44,44],[42,42]]],[1536387252428,["hsliu5@hsliu5",[[1,42,"lu"]],[42,42],[44,44]]],[1536387253621,["hsliu5@hsliu5",[[1,44,"splua"]],[44,44],[49,49]]],[1536387253997,["hsliu5@hsliu5",[[1,50,"\n"]],[49,49],[50,50]]],[1536387255085,["hsliu5@hsliu5",[[-1,50,"\n"]],[50,50],[49,49]]],[1536387255296,["hsliu5@hsliu5",[[-1,48,"a"]],[49,49],[48,48]]],[1536387255705,["hsliu5@hsliu5",[[1,48,"s"]],[48,48],[49,49]]],[1536387256065,["hsliu5@hsliu5",[[1,50,"\n"]],[49,49],[50,50]]],[1536387256753,["hsliu5@hsliu5",[[-1,50,"\n"]],[50,50],[49,49]]],[1536387257021,["hsliu5@hsliu5",[[-1,48,"s"]],[49,49],[48,48]]],[1536387257656,["hsliu5@hsliu5",[[1,48,"s"]],[48,48],[49,49]]],[1536387257939,["hsliu5@hsliu5",[[1,50,"\n"]],[49,49],[50,50]]],[1536387270289,["hsliu5@hsliu5",[[1,50,"```c\nint *p = (int *) malloc(10*sizeof(int));\n```"]],[50,50],[99,99]]],[1536387272605,["hsliu5@hsliu5",[[-1,50,"```c"]],[50,54],[50,50]]],[1536387272840,["hsliu5@hsliu5",[[-1,50,"\n"]],[50,50],[49,49]]],[1536387273869,["hsliu5@hsliu5",[[-1,91,"```"]],[91,94],[91,91]]],[1536387274231,["hsliu5@hsliu5",[[-1,91,"\n"]],[91,91],[90,90]]],[1536387283083,["hsliu5@hsliu5",[[1,97,"\n"]],[94,94],[95,95]]],[1536387286768,["hsliu5@hsliu5",[[1,91,"\n"]],[90,90],[91,91]]],[1536387289885,["hsliu5@hsliu5",[[1,91,"p++;\nfree(p);"]],[91,91],[104,104]]],[1536387295480,["hsliu5@hsliu5",[[1,104,"  // ba"]],[104,104],[111,111]]],[1536387296662,["hsliu5@hsliu5",[[-1,109,"ba"]],[111,111],[109,109]]],[1536387303636,["hsliu5@hsliu5",[[1,109,"报异常错误"]],[109,109],[114,114]]],[1536387329247,["hsliu5@hsliu5",[[1,122,"\n"]],[119,119],[120,120]]],[1536387330997,["hsliu5@hsliu5",[[1,120,"1. "]],[120,120],[123,123]]],[1536387334628,["hsliu5@hsliu5",[[1,119,"te"]],[119,119],[118,121]]],[1536387336298,["hsliu5@hsliu5",[[-1,118,"\nte\n"],[1,122,"特别注意"]],[118,118],[122,122]]],[1536387337420,["hsliu5@hsliu5",[[-1,117,"`特别注意"]],[122,122],[117,117]]],[1536387338735,["hsliu5@hsliu5",[[1,117,"`特别注意"]],[117,117],[122,122]]],[1536387341046,["hsliu5@hsliu5",[[-1,118,"特别注意"]],[122,122],[118,118]]],[1536387341526,["hsliu5@hsliu5",[[1,118,"\n"]],[118,118],[119,119]]],[1536387342624,["hsliu5@hsliu5",[[1,119,"\n"]],[119,119],[120,120]]],[1536387344280,["hsliu5@hsliu5",[[1,120,"\n"]],[119,119],[120,120]]],[1536387347392,["hsliu5@hsliu5",[[1,120,"特别注意"]],[120,120],[124,124]]],[1536387350065,["hsliu5@hsliu5",[[1,120,"**"],[1,124,"**"]],[120,124],[120,128]]],[1536387364527,["hsliu5@hsliu5",[[1,132,"不能用delete和"]],[132,132],[142,142]]],[1536387400337,["hsliu5@hsliu5",[[1,142,"free释放非动态变量，报异常错误；2. \n另外，用delete和free撤销动态数组时，其中的指针变量必须指向数组的第一个元素。"]],[142,142],[207,207]]],[1536387407401,[null,[[1,160,"\n"],[-1,163,"\n"]],[160,160],[163,163]]],[1536387407401,[null,[[-1,160,"\n"],[1,164,"\n"]],[163,163],[160,160]]],[1536387405553,["hsliu5@hsliu5",[[-1,164,"另外，"]],[164,167],[164,164]]],[1536387473565,[null,[[1,160,"\n"],[-1,163,"\n"]],[160,160],[163,163]]],[1536387473566,[null,[[-1,160,"\n"],[1,164,"\n"]],[163,163],[160,160]]],[1536387468748,["hsliu5@hsliu5",[[1,119,"malloc分配的区块是带有metadata的，里面记录了区块的大小等必要的信息。malloc返回的指针经过free调用的时候会先找到metadata再进行释放，也就是说如果你喂给free一个别的指针的话那肯定是会报错的"]],[119,119],[229,229]]],[1536387470482,["hsliu5@hsliu5",[[1,230,"\n"]],[229,229],[230,230]]],[1536387472154,["hsliu5@hsliu5",[[1,231,"\n"]],[230,230],[231,231]]],[1536387484039,[null,[[1,272,"\n"],[-1,275,"\n"]],[272,272],[275,275]]],[1536387484039,[null,[[-1,272,"\n"],[1,276,"\n"]],[275,275],[272,272]]],[1536387475425,["hsliu5@hsliu5",[[-1,231,"\n"]],[230,230],[229,229]]],[1536387482980,["hsliu5@hsliu5",[[1,229,"。"]],[229,229],[230,230]]]],null,"hsliu5@hsliu5"],["0a04cbcc-a086-4d1f-9354-ce55a579fb99",1536981982881,"每天积累一点，加油！\n\n## C++指针free是如何知道内存块大小的？\n```cplusplus\nint *p = (int *) malloc(10*sizeof(int));\np++;\nfree(p);  // 报异常错误\n```\nmalloc分配的区块是带有metadata的，里面记录了区块的大小等必要的信息。malloc返回的指针经过free调用的时候会先找到metadata再进行释放，也就是说如果你喂给free一个别的指针的话那肯定是会报错的。\n\n**特别注意**\n1. 不能用delete和free释放非动态变量，报异常错误；\n2. 用delete和free撤销动态数组时，其中的指针变量必须指向数组的第一个元素。\n\n\n## 参考\n* <http://www.yolinux.com/TUTORIALS/GDB-Commands.html>",[[1536981929527,["hsliu5@hsliu5",[[1,319,"\n"]],[317,317],[318,318]]],[1536981964195,["hsliu5@hsliu5",[[1,318,"## static_cast和reinterpre——"]],[318,318],[345,345]]],[1536981965348,["hsliu5@hsliu5",[[-1,343,"——"]],[345,345],[343,343]]],[1536981970421,["hsliu5@hsliu5",[[1,343,"_cast差别"]],[343,343],[350,350]]],[1536981973755,["hsliu5@hsliu5",[[-1,327,"_"]],[328,328],[327,327]]],[1536981973989,["hsliu5@hsliu5",[[1,327,"-"]],[327,327],[328,328]]],[1536981976133,["hsliu5@hsliu5",[[-1,343,"_"]],[344,344],[343,343]]],[1536981976368,["hsliu5@hsliu5",[[1,343,"-"]],[343,343],[344,344]]],[1536981985916,["hsliu5@hsliu5",[[1,343,"t"]],[343,343],[344,344]]],[1536981991648,["hsliu5@hsliu5",[[1,321,"C++"]],[321,321],[324,324]]],[1536981993488,["hsliu5@hsliu5",[[1,324,"++zhong "]],[324,324],[330,330]]],[1536981994799,["hsliu5@hsliu5",[[-1,324,"zhong "]],[330,330],[324,324]]],[1536981996050,["hsliu5@hsliu5",[[1,324,"中"]],[324,324],[325,325]]],[1536981997932,["hsliu5@hsliu5",[[-1,325,"++"]],[327,327],[325,325]]],[1536982000318,["hsliu5@hsliu5",[[1,357,"\n"]],[355,355],[356,356]]],[1536982000902,["hsliu5@hsliu5",[[1,358,"\n"]],[356,356],[357,357]]],[1536982041423,["hsliu5@hsliu5",[[1,357,"1. static_cast"]],[357,357],[371,371]]],[1536982049851,["hsliu5@hsliu5",[[-1,357,"1. "]],[357,360],[357,357]]],[1536982052431,["hsliu5@hsliu5",[[1,357,"### "]],[357,357],[361,361]]],[1536982054952,["hsliu5@hsliu5",[[1,374,"\n"]],[372,372],[373,373]]],[1536982059835,["hsliu5@hsliu5",[[-1,356,"\n"]],[356,356],[355,355]]],[1536982082812,["hsliu5@hsliu5",[[1,372,"作用："]],[372,372],[375,375]]],[1536982084611,["hsliu5@hsliu5",[[1,377,"\n"]],[375,375],[376,376]]],[1536982086346,["hsliu5@hsliu5",[[1,376,"1. "]],[376,376],[379,379]]],[1536982090045,["hsliu5@hsliu5",[[-1,371,"\n"]],[372,372],[371,371]]],[1536982092227,["hsliu5@hsliu5",[[-1,373,"："]],[374,374],[373,373]]],[1536982100278,["hsliu5@hsliu5",[[1,373,"："]],[373,373],[374,374]]],[1536982106455,["hsliu5@hsliu5",[[-1,373,"："]],[374,374],[373,373]]],[1536982119893,["hsliu5@hsliu5",[[1,377,"类层次中积累和"]],[377,377],[384,384]]],[1536982120713,["hsliu5@hsliu5",[[-1,381,"积累和"]],[384,384],[381,381]]],[1536982132429,["hsliu5@hsliu5",[[1,381,"基类和子类的指针类型"]],[381,381],[391,391]]],[1536982137374,["hsliu5@hsliu5",[[1,389,"或引用"]],[389,389],[392,392]]],[1536982160116,["hsliu5@hsliu5",[[1,394,"转换：《》"]],[394,394],[399,399]]],[1536982160949,["hsliu5@hsliu5",[[-1,397,"《》"]],[399,399],[397,397]]],[1536982161593,["hsliu5@hsliu5",[[1,397,"<>"]],[397,397],[399,399]]],[1536982162818,["hsliu5@hsliu5",[[1,398,"shang"]],[398,398],[403,403]]],[1536982163729,["hsliu5@hsliu5",[[-1,398,"shang"]],[403,403],[398,398]]],[1536982172366,["hsliu5@hsliu5",[[1,398,"上行转换：子类到基本"]],[398,398],[408,408]]],[1536982173280,["hsliu5@hsliu5",[[-1,407,"本"]],[408,408],[407,407]]],[1536982174498,["hsliu5@hsliu5",[[1,407,"类"]],[407,407],[408,408]]],[1536982178289,["hsliu5@hsliu5",[[1,409,"安全的"]],[409,409],[412,412]]],[1536982179013,["hsliu5@hsliu5",[[-1,411,"的"]],[412,412],[411,411]]],[1536982180079,["hsliu5@hsliu5",[[1,411,"，"]],[411,411],[412,412]]],[1536982181689,["hsliu5@hsliu5",[[1,413,"》"]],[413,413],[414,414]]],[1536982182422,["hsliu5@hsliu5",[[-1,412,"《》"]],[414,414],[412,412]]],[1536982183018,["hsliu5@hsliu5",[[1,412,"<>"]],[412,412],[414,414]]],[1536982184088,["hsliu5@hsliu5",[[1,413,"xia"]],[413,413],[416,416]]],[1536982184748,["hsliu5@hsliu5",[[-1,413,"xia"]],[416,416],[413,413]]],[1536982185271,["hsliu5@hsliu5",[[1,413,"xia"]],[413,413],[416,416]]],[1536982186112,["hsliu5@hsliu5",[[-1,413,"xia"]],[416,416],[413,413]]],[1536982186273,["hsliu5@hsliu5",[[1,413,"x"]],[413,413],[414,414]]],[1536982187056,["hsliu5@hsliu5",[[-1,413,"x"]],[414,414],[413,413]]],[1536982196364,["hsliu5@hsliu5",[[1,413,"下行转换：基类到子类"]],[413,413],[423,423]]],[1536982199240,["hsliu5@hsliu5",[[1,424,"不安全"]],[424,424],[427,427]]],[1536982226071,["hsliu5@hsliu5",[[1,424,"无运行时动态类型检查，"]],[424,424],[435,435]]],[1536982241185,["hsliu5@hsliu5",[[1,438,"；2. \n用于基本类型之间的"]],[438,438],[452,452]]],[1536982301574,[null,[[1,439,"\n"],[-1,442,"\n"],[1,452,"\n"]],[439,439],[453,453]]],[1536982301574,[null,[[-1,439,"\n"],[1,443,"\n"],[-1,452,"\n"]],[453,453],[439,439]]],[1536982299910,["hsliu5@hsliu5",[[1,452,"转换，如char2int，安全靠程序猿自己把握；3. \nvoid指针与其它类型指针"]],[452,452],[493,493]]],[1536982361588,[null,[[1,439,"\n"],[-1,442,"\n"],[1,476,"\n"],[-1,479,"\n"],[1,493,"\n"]],[439,439],[494,494]]],[1536982361588,[null,[[-1,439,"\n"],[1,443,"\n"],[-1,476,"\n"],[1,480,"\n"],[-1,493,"\n"]],[494,494],[439,439]]],[1536982325427,["hsliu5@hsliu5",[[1,493,"之间的转换；4. \n"]],[493,493],[503,503]]],[1536982327568,["hsliu5@hsliu5",[[-1,500,"4. "]],[503,503],[500,500]]],[1536982331125,["hsliu5@hsliu5",[[1,500,"warning： "]],[500,500],[509,509]]],[1536982335831,["hsliu5@hsliu5",[[1,500,"**"],[1,507,"**"]],[500,507],[500,511]]],[1536982337409,["hsliu5@hsliu5",[[-1,500,"**"],[-1,509,"**"]],[500,511],[500,507]]],[1536982338645,["hsliu5@hsliu5",[[1,500,"_"],[1,507,"_"]],[500,507],[500,509]]],[1536982340050,["hsliu5@hsliu5",[[-1,500,"_"],[-1,508,"_"]],[500,509],[500,507]]],[1536982344666,["hsliu5@hsliu5",[[1,500,"++"],[1,507,"++"]],[500,507],[500,511]]],[1536982347055,["hsliu5@hsliu5",[[-1,500,"++"],[-1,509,"++"]],[500,511],[500,507]]],[1536982353611,["hsliu5@hsliu5",[[1,500,"**"],[1,507,"**"]],[500,507],[500,511]]],[1536982421576,[null,[[1,439,"\n"],[-1,442,"\n"],[1,476,"\n"],[-1,479,"\n"],[-1,499,"4"],[1,500,"\n"],[1,513,"\n"]],[439,439],[514,514]]],[1536982421576,[null,[[-1,439,"\n"],[1,443,"\n"],[-1,476,"\n"],[1,480,"\n"],[1,499,"4"],[-1,499,"\n"],[-1,513,"\n"]],[514,514],[439,439]]],[1536982369699,["hsliu5@hsliu5",[[1,513,"static-castbun"]],[513,513],[527,527]]],[1536982370502,["hsliu5@hsliu5",[[-1,523,"tbun"]],[527,527],[523,523]]],[1536982387428,["hsliu5@hsliu5",[[1,523,"t保留指针const\\"]],[523,523],[534,534]]],[1536982387968,["hsliu5@hsliu5",[[-1,533,"\\"]],[534,534],[533,533]]],[1536982388620,["hsliu5@hsliu5",[[1,533,"，"]],[533,533],[534,534]]],[1536982389252,["hsliu5@hsliu5",[[-1,533,"，"]],[534,534],[533,533]]],[1536982404619,["hsliu5@hsliu5",[[1,533,", volatile, _"]],[533,533],[546,546]]],[1536982404774,["hsliu5@hsliu5",[[1,546,"__"]],[546,546],[547,547]]],[1536982408073,["hsliu5@hsliu5",[[-1,544," ___"]],[547,547],[544,544]]],[1536982412402,["hsliu5@hsliu5",[[1,544," 等属性"]],[544,544],[548,548]]],[1536982413452,["hsliu5@hsliu5",[[1,550,"\n"]],[548,548],[549,549]]],[1536982481586,[null,[[1,439,"\n"],[-1,442,"\n"],[1,476,"\n"],[-1,479,"\n"],[-1,499,"4"],[1,500,"\n"],[1,549,"\n\n"],[-1,550,"\n"]],[439,439],[550,550]]],[1536982481586,[null,[[-1,439,"\n"],[1,443,"\n"],[-1,476,"\n"],[1,480,"\n"],[1,499,"4"],[-1,499,"\n"],[-1,549,"\n\n"],[1,552,"\n"]],[550,550],[439,439]]],[1536982481328,["hsliu5@hsliu5",[[1,549,"### reinterpret"]],[549,549],[564,564]]],[1536982541594,[null,[[1,439,"\n"],[-1,442,"\n"],[1,476,"\n"],[-1,479,"\n"],[-1,499,"4"],[1,500,"\n"],[1,564,"\n\n"],[-1,565,"\n"]],[439,439],[565,565]]],[1536982541594,[null,[[-1,439,"\n"],[1,443,"\n"],[-1,476,"\n"],[1,480,"\n"],[1,499,"4"],[-1,499,"\n"],[-1,564,"\n\n"],[1,567,"\n"]],[565,565],[439,439]]],[1536982486659,["hsliu5@hsliu5",[[1,564,"-cast作用"]],[564,564],[571,571]]],[1536982487665,["hsliu5@hsliu5",[[1,573,"\n"]],[571,571],[572,572]]],[1536982528917,["hsliu5@hsliu5",[[1,572,"重点："]],[572,572],[575,575]]],[1536982531811,["hsliu5@hsliu5",[[-1,572,"重点"],[1,574,"k"]],[572,574],[572,573]]],[1536982532348,["hsliu5@hsliu5",[[1,573,"ey"]],[572,572],[575,575]]],[1536982536653,["hsliu5@hsliu5",[[-1,572,"key"],[1,575,"KEY"]],[572,575],[575,575]]],[1536982582024,[null,[[1,439,"\n"],[-1,442,"\n"],[1,476,"\n"],[-1,479,"\n"],[-1,499,"4"],[1,500,"\n"],[-1,571,"#"],[1,572,"\n"],[1,578,"#"]],[439,439],[579,579]]],[1536982582024,[null,[[-1,439,"\n"],[1,443,"\n"],[-1,476,"\n"],[1,480,"\n"],[1,499,"4"],[-1,499,"\n"],[1,571,"#"],[-1,571,"\n"],[-1,578,"#"]],[579,579],[439,439]]],[1536982548562,["hsliu5@hsliu5",[[1,576,"通常为操作数的位模式提供较低层的重新解释；"]],[576,576],[597,597]]],[1536982548828,["hsliu5@hsliu5",[[1,599,"\n"]],[597,597],[598,598]]],[1536982574933,["hsliu5@hsliu5",[[1,598,"···"]],[598,598],[601,601]]],[1536982575645,["hsliu5@hsliu5",[[-1,599,"··"]],[601,601],[599,599]]],[1536982575960,["hsliu5@hsliu5",[[1,599,"·"]],[599,599],[600,600]]],[1536982576576,["hsliu5@hsliu5",[[-1,598,"··"]],[600,600],[598,598]]],[1536982578702,["hsliu5@hsliu5",[[1,598,"```"]],[598,598],[601,601]]],[1536982578727,["hsliu5@hsliu5",[[1,601,"language\n```\n"]],[601,601],[601,609]]],[1536982580058,["hsliu5@hsliu5",[[-1,601,"language"],[1,609,"c"]],[601,609],[602,602]]],[1536982581273,["hsliu5@hsliu5",[[1,603,"\n"]],[602,602],[603,603]]],[1536982626705,[null,[[1,439,"\n"],[-1,442,"\n"],[1,476,"\n"],[-1,479,"\n"],[-1,499,"4"],[1,500,"\n"],[-1,571,"#"],[1,572,"\n"],[1,610,"#"]],[439,439],[611,611]]],[1536982626705,[null,[[-1,439,"\n"],[1,443,"\n"],[-1,476,"\n"],[1,480,"\n"],[1,499,"4"],[-1,499,"\n"],[1,571,"#"],[-1,571,"\n"],[-1,610,"#"]],[611,611],[439,439]]],[1536982590536,["hsliu5@hsliu5",[[1,603,"int i;"]],[603,603],[609,609]]],[1536982590747,["hsliu5@hsliu5",[[1,610,"\n"]],[609,609],[610,610]]],[1536982598783,["hsliu5@hsliu5",[[1,610,"char* p = \"\""]],[610,610],[622,622]]],[1536982606017,["hsliu5@hsliu5",[[1,621,"This is an example"]],[621,621],[639,639]]],[1536982607287,["hsliu5@hsliu5",[[1,640,";"]],[640,640],[641,641]]],[1536982607492,["hsliu5@hsliu5",[[1,642,"\n"]],[641,641],[642,642]]],[1536982618485,["hsliu5@hsliu5",[[1,642,"i = reinterpret_cast<>"]],[642,642],[664,664]]],[1536982619872,["hsliu5@hsliu5",[[1,663,"int"]],[663,663],[666,666]]],[1536982622325,["hsliu5@hsliu5",[[1,667,"（）"]],[667,667],[669,669]]],[1536982623444,["hsliu5@hsliu5",[[-1,667,"（）"]],[669,669],[667,667]]],[1536982624184,["hsliu5@hsliu5",[[1,667,"()"]],[667,667],[669,669]]],[1536982625237,["hsliu5@hsliu5",[[1,668,"p"]],[668,668],[669,669]]],[1536982626387,["hsliu5@hsliu5",[[1,670,";"]],[670,670],[671,671]]],[1536982733567,[null,[[1,439,"\n"],[-1,442,"\n"],[1,476,"\n"],[-1,479,"\n"],[-1,499,"4"],[1,500,"\n"],[-1,571,"#"],[1,572,"\n"],[1,678,"#"]],[439,439],[679,679]]],[1536982733567,[null,[[-1,439,"\n"],[1,443,"\n"],[-1,476,"\n"],[1,480,"\n"],[1,499,"4"],[-1,499,"\n"],[1,571,"#"],[-1,571,"\n"],[-1,678,"#"]],[679,679],[439,439]]],[1536982696179,["hsliu5@hsliu5",[[1,676,"++"]],[676,676],[678,678]]],[1536982696203,["hsliu5@hsliu5",[[1,678,"++"]],[678,678],[678,678]]],[1536982697092,["hsliu5@hsliu5",[[-1,676,"++"]],[678,678],[676,676]]],[1536982698562,["hsliu5@hsliu5",[[-1,676,"++"]],[678,678],[676,676]]],[1536982701741,["hsliu5@hsliu5",[[1,676,"### qita"]],[676,676],[684,684]]],[1536982702628,["hsliu5@hsliu5",[[-1,680,"qita"]],[684,684],[680,680]]],[1536982704722,["hsliu5@hsliu5",[[1,680,"其他"]],[680,680],[682,682]]],[1536982706121,["hsliu5@hsliu5",[[1,684,"\n"]],[682,682],[683,683]]],[1536982720577,["hsliu5@hsliu5",[[1,683,"1. **dynamic_cast**"]],[683,683],[702,702]]],[1536982722159,["hsliu5@hsliu5",[[-1,695,"_"]],[696,696],[695,695]]],[1536982722460,["hsliu5@hsliu5",[[1,695,"-"]],[695,695],[696,696]]],[1536982725841,["hsliu5@hsliu5",[[-1,700,"**"]],[702,702],[700,700]]],[1536982729288,["hsliu5@hsliu5",[[-1,686,"**"]],[688,688],[686,686]]],[1536982732816,["hsliu5@hsliu5",[[1,698,"："]],[698,698],[699,699]]],[1536982793586,[null,[[1,439,"\n"],[-1,442,"\n"],[1,476,"\n"],[-1,479,"\n"],[-1,499,"4"],[1,500,"\n"],[-1,571,"#"],[1,572,"\n"],[1,701,"#"]],[439,439],[702,702]]],[1536982793586,[null,[[-1,439,"\n"],[1,443,"\n"],[-1,476,"\n"],[1,480,"\n"],[1,499,"4"],[-1,499,"\n"],[1,571,"#"],[-1,571,"\n"],[-1,701,"#"]],[702,702],[439,439]]],[1536982756811,["hsliu5@hsliu5",[[1,699,"“”"]],[699,699],[701,701]]],[1536982758891,["hsliu5@hsliu5",[[1,700,"q"]],[700,700],[701,701]]],[1536982759285,["hsliu5@hsliu5",[[-1,700,"q"]],[701,701],[700,700]]],[1536982764063,["hsliu5@hsliu5",[[1,700,"安全地线下"]],[700,700],[705,705]]],[1536982764908,["hsliu5@hsliu5",[[-1,703,"线下"]],[705,705],[703,703]]],[1536982768817,["hsliu5@hsliu5",[[1,703,"向下转换"]],[703,703],[707,707]]],[1536982782349,["hsliu5@hsliu5",[[1,708,"，即下行转换前会动态检查；2. \n"]],[708,708],[725,725]]],[1536982833429,[null,[[1,439,"\n"],[-1,442,"\n"],[1,476,"\n"],[-1,479,"\n"],[-1,499,"4"],[1,500,"\n"],[-1,571,"#"],[1,572,"\n"],[1,721,"\n"],[-1,726,"\n"],[1,727,"#"]],[439,439],[728,728]]],[1536982833429,[null,[[-1,439,"\n"],[1,443,"\n"],[-1,476,"\n"],[1,480,"\n"],[1,499,"4"],[-1,499,"\n"],[1,571,"#"],[-1,571,"\n"],[-1,721,"\n"],[1,727,"\n"],[-1,727,"#"]],[728,728],[439,439]]],[1536982809581,["hsliu5@hsliu5",[[1,725,"consta"]],[725,725],[731,731]]],[1536982810447,["hsliu5@hsliu5",[[-1,729,"ta"]],[731,731],[729,729]]],[1536982814930,["hsliu5@hsliu5",[[1,729,"t-cast："]],[729,729],[736,736]]],[1536982816304,["hsliu5@hsliu5",[[-1,735,"："]],[736,736],[735,735]]],[1536982823189,["hsliu5@hsliu5",[[1,735,": q"]],[735,735],[738,738]]],[1536982823861,["hsliu5@hsliu5",[[-1,737,"q"]],[738,738],[737,737]]],[1536982832983,["hsliu5@hsliu5",[[1,737,"强制消除对象的const属性；"]],[737,737],[752,752]]]],null,"hsliu5@hsliu5"],["1e0e7ef6-edc6-4676-a9d3-903d18714bc2",1537343318544,"每天积累一点，加油！\n\n## C++指针free是如何知道内存块大小的？\n```cplusplus\nint *p = (int *) malloc(10*sizeof(int));\np++;\nfree(p);  // 报异常错误\n```\nmalloc分配的区块是带有metadata的，里面记录了区块的大小等必要的信息。malloc返回的指针经过free调用的时候会先找到metadata再进行释放，也就是说如果你喂给free一个别的指针的话那肯定是会报错的。\n\n**特别注意**\n1. 不能用delete和free释放非动态变量，报异常错误；\n2. 用delete和free撤销动态数组时，其中的指针变量必须指向数组的第一个元素。\n\n## C++中static-cast和reinterpret-cast差别\n### static_cast作用\n1. 类层次中基类和子类的指针或引用类型转换：<上行转换：子类到基类>安全，<下行转换：基类到子类>无运行时动态类型检查，不安全；\n2. 用于基本类型之间的转换，如char2int，安全靠程序猿自己把握；\n3. void指针与其它类型指针之间的转换；\n**warning**： static-cast保留指针const, volatile, 等属性\n### reinterpret-cast作用\nKEY：通常为操作数的位模式提供较低层的重新解释；\n```c\nint i;\nchar* p = \"This is an example\";\ni = reinterpret_cast<int>(p);\n```\n### 其他\n1. dynamic-cast：“安全地向下转换”，即下行转换前会动态检查；\n2. const-cast: 强制消除对象的const属性；\n\n## 参考\n* <http://www.yolinux.com/TUTORIALS/GDB-Commands.html>",[[1537343286296,["hsliu5@hsliu5",[[1,754,"\n"]],[753,753],[754,754]]],[1537343286645,["hsliu5@hsliu5",[[1,755,"\n"]],[754,754],[755,755]]],[1537343286852,["hsliu5@hsliu5",[[1,756,"\n"]],[755,755],[756,756]]],[1537343303164,["hsliu5@hsliu5",[[1,754,"## 智能指针SHAR"]],[754,754],[765,765]]],[1537343304041,["hsliu5@hsliu5",[[-1,761,"SHAR"]],[765,765],[761,761]]],[1537343316501,["hsliu5@hsliu5",[[1,761,"shared_ptrxun"]],[761,761],[774,774]]],[1537343317275,["hsliu5@hsliu5",[[-1,771,"xun"]],[774,774],[771,771]]],[1537343322490,["hsliu5@hsliu5",[[1,771,"循环引用问题"]],[771,771],[777,777]]],[1537343323415,["hsliu5@hsliu5",[[1,780,"\n"]],[777,777],[778,778]]],[1537343345715,["hsliu5@hsliu5",[[1,778,"### 循环引用问题"]],[778,778],[788,788]]],[1537343346065,["hsliu5@hsliu5",[[1,791,"\n"]],[788,788],[789,789]]],[1537343376470,["hsliu5@hsliu5",[[1,789,"智能指针shared_ptr采用引用计数的方法"]],[789,789],[812,812]]],[1537343377872,["hsliu5@hsliu5",[[-1,810,"方法"]],[812,812],[810,810]]],[1537343396988,["hsliu5@hsliu5",[[1,810,"方式来记录指针的"]],[810,810],[818,818]]],[1537343397502,["hsliu5@hsliu5",[[-1,817,"的"]],[818,818],[817,817]]],[1537343398588,["hsliu5@hsliu5",[[1,817,"的"]],[817,817],[818,818]]],[1537343405767,["hsliu5@hsliu5",[[-1,817,"的"]],[818,818],[817,817]]],[1537343425927,["hsliu5@hsliu5",[[1,817,"引用"]],[817,817],[819,819]]],[1537343429836,["hsliu5@hsliu5",[[-1,817,"引用"]],[819,819],[817,817]]],[1537343435953,["hsliu5@hsliu5",[[1,820,"\n"]],[817,817],[818,818]]],[1537343437301,["hsliu5@hsliu5",[[1,818,"··"]],[818,818],[820,820]]],[1537343437551,["hsliu5@hsliu5",[[1,820,"·"]],[820,820],[821,821]]],[1537343438273,["hsliu5@hsliu5",[[-1,818,"···"]],[821,821],[818,818]]],[1537343439438,["hsliu5@hsliu5",[[1,818,"```"]],[818,818],[821,821]]],[1537343439464,["hsliu5@hsliu5",[[1,821,"language\n```\n"]],[821,821],[821,829]]],[1537343441194,["hsliu5@hsliu5",[[-1,821,"language"],[1,829,"c"]],[821,829],[821,822]]],[1537343441883,["hsliu5@hsliu5",[[1,823,"\n"]],[822,822],[823,823]]],[1537343455398,["hsliu5@hsliu5",[[1,827,"#include<iostream>\n#include<memory>\nusing namespace std;\n\nstruct Node\n{\n    int _value;\n    shared_ptr<Node> _next;\n    shared_ptr<Node> _prev;\n};\n\nint main()\n{\n    shared_ptr<Node> sp1(new Node);\n    shared_ptr<Node> sp2(new Node);\n\n    sp1->_next = sp2;\n    sp2->_prev = sp1;\n\n    cout<<sp1.use_count()<<endl; //引用计数-->2\n    cout << sp2.use_count() << endl;//引用计数-->2\n    system(\"pause\");\n    return 0;\n}"]],[827,827],[1233,1233]]],[1537343458519,["hsliu5@hsliu5",[[-1,823,"\n```"]],[823,827],[823,823]]],[1537343470166,["hsliu5@hsliu5",[[-1,880,"\n"]],[880,880],[879,879]]],[1537343472073,["hsliu5@hsliu5",[[-1,969,"\n"]],[969,969],[968,968]]],[1537343474985,["hsliu5@hsliu5",[[1,1231,"\n"]],[1227,1227],[1228,1228]]],[1537343476548,["hsliu5@hsliu5",[[1,1228,"··"]],[1228,1228],[1230,1230]]],[1537343477474,["hsliu5@hsliu5",[[-1,1228,"··"]],[1230,1230],[1228,1228]]],[1537343477717,["hsliu5@hsliu5",[[-1,1231,"\n"]],[1228,1228],[1227,1227]]],[1537343478524,["hsliu5@hsliu5",[[1,1231,"\n"]],[1227,1227],[1228,1228]]],[1537343479556,["hsliu5@hsliu5",[[1,1228,"```"]],[1228,1228],[1231,1231]]],[1537343486040,["hsliu5@hsliu5",[[-1,1054,"\n"]],[1054,1054],[1053,1053]]],[1537343488007,["hsliu5@hsliu5",[[-1,1098,"\n"]],[1098,1098],[1097,1097]]],[1537343519761,["hsliu5@hsliu5",[[1,12,"\n"]],[10,10],[11,11]]],[1537343536762,["hsliu5@hsliu5",[[1,12,"@toc\n\n\n"]],[11,11],[18,18]]],[1537343539731,["hsliu5@hsliu5",[[-1,19,"\n"]],[18,18],[17,17]]],[1537343540354,["hsliu5@hsliu5",[[-1,18,"\n"]],[17,17],[16,16]]],[1537343558088,["hsliu5@hsliu5",[[1,21,"1. "]],[21,21],[24,24]]],[1537343563325,["hsliu5@hsliu5",[[1,330,"2. "]],[330,330],[333,333]]],[1537343567481,["hsliu5@hsliu5",[[1,769,"3. "]],[769,769],[772,772]]],[1537343636971,["hsliu5@hsliu5",[[1,832,","]],[832,832],[833,833]]],[1537343638019,["hsliu5@hsliu5",[[-1,832,","]],[833,833],[832,832]]],[1537343644317,["hsliu5@hsliu5",[[1,832,"，zai"]],[832,832],[836,836]]],[1537343645050,["hsliu5@hsliu5",[[-1,833,"zai"]],[836,836],[833,833]]],[1537343668729,["hsliu5@hsliu5",[[1,833,"在双向链表使用时会出现循环引用问题，如例子所示："]],[833,833],[857,857]]],[1537343735830,["hsliu5@hsliu5",[[1,1265," //ruhe"]],[1265,1265],[1272,1272]]],[1537343736629,["hsliu5@hsliu5",[[-1,1268,"ruhe"]],[1272,1272],[1268,1268]]],[1537343741604,["hsliu5@hsliu5",[[1,1268,"如何政治"]],[1268,1268],[1272,1272]]],[1537343742282,["hsliu5@hsliu5",[[-1,1270,"政治"]],[1272,1272],[1270,1270]]],[1537343748324,["hsliu5@hsliu5",[[1,1270,"真正销毁死屏"]],[1270,1270],[1276,1276]]],[1537343748520,["hsliu5@hsliu5",[[1,1277,"\n"]],[1276,1276],[1277,1277]]],[1537343750337,["hsliu5@hsliu5",[[-1,1277,"\n"]],[1277,1277],[1276,1276]]],[1537343751417,["hsliu5@hsliu5",[[-1,1274,"死屏"]],[1276,1276],[1274,1274]]],[1537343762849,["hsliu5@hsliu5",[[1,1274,"sp1指向的Node？"]],[1274,1274],[1285,1285]]],[1537343780552,["hsliu5@hsliu5",[[1,833,"只有引用计数未"]],[833,833],[840,840]]],[1537343781315,["hsliu5@hsliu5",[[-1,839,"未"]],[840,840],[839,839]]],[1537343787877,["hsliu5@hsliu5",[[1,839,"为1时才执行"]],[839,839],[845,845]]],[1537343797120,["hsliu5@hsliu5",[[1,845,"delete销毁对象，"]],[845,845],[856,856]]],[1537343799282,["hsliu5@hsliu5",[[-1,855,"，"]],[856,856],[855,855]]],[1537343799556,["hsliu5@hsliu5",[[1,855,"。"]],[855,855],[856,856]]],[1537343817595,["hsliu5@hsliu5",[[1,1308,"先销毁"]],[1308,1308],[1311,1311]]],[1537343818233,["hsliu5@hsliu5",[[-1,1308,"先销毁"]],[1311,1311],[1308,1308]]],[1537343819948,["hsliu5@hsliu5",[[1,1308,"需要"]],[1308,1308],[1310,1310]]],[1537343820609,["hsliu5@hsliu5",[[-1,1308,"需要"]],[1310,1310],[1308,1308]]],[1537343825303,["hsliu5@hsliu5",[[1,1308,"先销毁视频"]],[1308,1308],[1313,1313]]],[1537343826167,["hsliu5@hsliu5",[[-1,1311,"视频"]],[1313,1313],[1311,1311]]],[1537343830071,["hsliu5@hsliu5",[[1,1311,"sp2-》"]],[1311,1311],[1316,1316]]],[1537343830662,["hsliu5@hsliu5",[[-1,1315,"》"]],[1316,1316],[1315,1315]]],[1537343837040,["hsliu5@hsliu5",[[1,1315,"--sp1---视频"]],[1315,1315],[1325,1325]]],[1537343838202,["hsliu5@hsliu5",[[-1,1323,"视频"]],[1325,1325],[1323,1323]]],[1537343842269,["hsliu5@hsliu5",[[1,1323,"sp2------"]],[1323,1323],[1332,1332]]],[1537345747275,["hsliu5@hsliu5",[[1,1337,"### weak_ptr解决"]],[1337,1337],[1351,1351]]],[1537345748142,["hsliu5@hsliu5",[[-1,1349,"解决"]],[1351,1351],[1349,1349]]],[1537345750960,["hsliu5@hsliu5",[[1,1349,"配合解决"]],[1349,1349],[1353,1353]]],[1537345751325,["hsliu5@hsliu5",[[1,1356,"\n"]],[1353,1353],[1354,1354]]],[1537345754151,["hsliu5@hsliu5",[[1,1353,"问题"]],[1353,1353],[1355,1355]]],[1537345782467,["hsliu5@hsliu5",[[1,1356,"通过一个shared_ptr或weak_ptr"]],[1356,1356],[1379,1379]]],[1537345784491,["hsliu5@hsliu5",[[-1,1375,"_"]],[1376,1376],[1375,1375]]],[1537345784713,["hsliu5@hsliu5",[[1,1375,"-"]],[1375,1375],[1376,1376]]],[1537345787094,["hsliu5@hsliu5",[[-1,1366,"_"]],[1367,1367],[1366,1366]]],[1537345787342,["hsliu5@hsliu5",[[1,1366,"-"]],[1366,1366],[1367,1367]]],[1537345804731,["hsliu5@hsliu5",[[1,1379,"对象构造，析构和狗仔"]],[1379,1379],[1389,1389]]],[1537345805284,["hsliu5@hsliu5",[[-1,1387,"狗仔"]],[1389,1389],[1387,1387]]],[1537345808197,["hsliu5@hsliu5",[[1,1387,"构造不会"]],[1387,1387],[1391,1391]]],[1537345814480,["hsliu5@hsliu5",[[-1,1393,"\n"]],[1392,1392],[1391,1391]]],[1537345820074,["hsliu5@hsliu5",[[1,1391,"引起引用指针的"]],[1391,1391],[1398,1398]]],[1537345828856,["hsliu5@hsliu5",[[1,1398,"增加和减少。"]],[1398,1398],[1404,1404]]],[1537345829463,["hsliu5@hsliu5",[[1,1406,"\n"]],[1404,1404],[1405,1405]]],[1537345839772,["hsliu5@hsliu5",[[1,1000," // 修改为"]],[1000,1000],[1007,1007]]],[1537345840709,["hsliu5@hsliu5",[[-1,1004,"修改为"]],[1007,1007],[1004,1004]]],[1537345843741,["hsliu5@hsliu5",[[1,1004,"modify："]],[1004,1004],[1011,1011]]],[1537345857527,["hsliu5@hsliu5",[[-1,1039,"\n"]],[1040,1040],[1039,1039]]],[1537345859017,["hsliu5@hsliu5",[[1,1039,"\n"]],[1039,1039],[1040,1040]]],[1537345868367,["hsliu5@hsliu5",[[1,1011,"weak_ptr《"]],[1011,1011],[1020,1020]]],[1537345868945,["hsliu5@hsliu5",[[-1,1019,"《"]],[1020,1020],[1019,1019]]],[1537345869978,["hsliu5@hsliu5",[[1,1019,"<>"]],[1019,1019],[1021,1021]]],[1537345871787,["hsliu5@hsliu5",[[1,1020,"Node"]],[1020,1020],[1024,1024]]],[1537345881735,["hsliu5@hsliu5",[[1,1053," // modify:weak_ptr<."]],[1053,1053],[1074,1074]]],[1537345882454,["hsliu5@hsliu5",[[-1,1073,"."]],[1074,1074],[1073,1073]]],[1537345882774,["hsliu5@hsliu5",[[1,1073,">"]],[1073,1073],[1074,1074]]],[1537345884316,["hsliu5@hsliu5",[[1,1073,"Node"]],[1073,1073],[1077,1077]]],[1537345887523,["hsliu5@hsliu5",[[-1,1010,"："],[1,1011,":"]],[1010,1011],[1011,1011]]]],null,"hsliu5@hsliu5"],["9f88a294-c707-42fe-8f49-927f13b1e0d6",1537424377209,"每天积累一点，加油！\n\n@toc\n\n## 1. C++指针free是如何知道内存块大小的？\n```cplusplus\nint *p = (int *) malloc(10*sizeof(int));\np++;\nfree(p);  // 报异常错误\n```\nmalloc分配的区块是带有metadata的，里面记录了区块的大小等必要的信息。malloc返回的指针经过free调用的时候会先找到metadata再进行释放，也就是说如果你喂给free一个别的指针的话那肯定是会报错的。\n\n**特别注意**\n1. 不能用delete和free释放非动态变量，报异常错误；\n2. 用delete和free撤销动态数组时，其中的指针变量必须指向数组的第一个元素。\n\n## 2. C++中static-cast和reinterpret-cast差别\n### static_cast作用\n1. 类层次中基类和子类的指针或引用类型转换：<上行转换：子类到基类>安全，<下行转换：基类到子类>无运行时动态类型检查，不安全；\n2. 用于基本类型之间的转换，如char2int，安全靠程序猿自己把握；\n3. void指针与其它类型指针之间的转换；\n**warning**： static-cast保留指针const, volatile, 等属性\n### reinterpret-cast作用\nKEY：通常为操作数的位模式提供较低层的重新解释；\n```c\nint i;\nchar* p = \"This is an example\";\ni = reinterpret_cast<int>(p);\n```\n### 其他\n1. dynamic-cast：“安全地向下转换”，即下行转换前会动态检查；\n2. const-cast: 强制消除对象的const属性；\n\n## 3. 智能指针shared_ptr循环引用问题\n### 循环引用问题\n智能指针shared_ptr采用引用计数的方式来记录指针，只有引用计数为1时才执行delete销毁对象。在双向链表使用时会出现循环引用问题，如例子所示：\n```c\n#include<iostream>\n#include<memory>\nusing namespace std;\nstruct Node\n{\n    int _value;\n    shared_ptr<Node> _next; // modify:weak_ptr<Node>\n    shared_ptr<Node> _prev; // modify:weak_ptr<Node>\n};\nint main()\n{\n    shared_ptr<Node> sp1(new Node);\n    shared_ptr<Node> sp2(new Node);\n    sp1->_next = sp2;\n    sp2->_prev = sp1;\n    cout<<sp1.use_count()<<endl; //引用计数-->2\n    cout << sp2.use_count() << endl;//引用计数-->2\n    system(\"pause\");\n    return 0;\n} //如何真正销毁sp1指向的Node？先销毁sp2---sp1---sp2------\n```\n### weak_ptr配合解决问题\n通过一个shared-ptr或weak-ptr对象构造，析构和构造不会引起引用指针的增加和减少。\n\n\n## 参考\n* <http://www.yolinux.com/TUTORIALS/GDB-Commands.html>",[[1537424371938,["hsliu5@hsliu5",[[1,1456,"## 对象生存周期\n在C++中存在四大类对象，分别为：\n1. **全局对象**：程序开始就构造，比main更早，程序结束main后析构；\n2. **局部对象**：对象诞生即构造，程序流程离开声明周期时，析构；\n3. **静态对象**：对象诞生即构造，程序结束main后析构，比全局对象早析构；\n4. **new产生的对象**：对象诞生即构造，delete即析构；\n\n### 代码演示\n```c\nGlobalClass gcls;  // 全局对象：其它文件通过关键字extern调用；\nstatic Demo1Class dcls1; // 静态全局对象：仅限本文件使用；\n// 全局对象：Global中存储；\n// 局部静态对象： Local Static中存储；\n\nint main(){\n  Demo2Class dcls2； // 局部对象：Stack栈中存储；\n  Demo3Class* dcls3 = new Demo3Class(); // new对象：Heap堆中存储；\n  delete dcls3;\n  return 0;\n}\n```"]],[1456,1456],[1934,1934]]],[1537424375705,["hsliu5@hsliu5",[[1,1935,"\n"]],[1934,1934],[1935,1935]]],[1537424375956,["hsliu5@hsliu5",[[1,1936,"\n"]],[1935,1935],[1936,1936]]],[1537424376146,["hsliu5@hsliu5",[[1,1937,"\n"]],[1936,1936],[1937,1937]]],[1537424376666,["hsliu5@hsliu5",[[1,1938,"\n"]],[1937,1937],[1938,1938]]],[1537424376806,["hsliu5@hsliu5",[[1,1939,"\n"]],[1938,1938],[1939,1939]]],[1537424389406,["hsliu5@hsliu5",[[1,1459,"4. "]],[1459,1459],[1462,1462]]]],null,"hsliu5@hsliu5"],["6cac776f-8759-41d6-b87e-45e04e952d09",1539170662576,"每天积累一点，加油！\n\n@toc\n\n## 1. C++指针free是如何知道内存块大小的？\n```cplusplus\nint *p = (int *) malloc(10*sizeof(int));\np++;\nfree(p);  // 报异常错误\n```\nmalloc分配的区块是带有metadata的，里面记录了区块的大小等必要的信息。malloc返回的指针经过free调用的时候会先找到metadata再进行释放，也就是说如果你喂给free一个别的指针的话那肯定是会报错的。\n\n**特别注意**\n1. 不能用delete和free释放非动态变量，报异常错误；\n2. 用delete和free撤销动态数组时，其中的指针变量必须指向数组的第一个元素。\n\n## 2. C++中static-cast和reinterpret-cast差别\n### static_cast作用\n1. 类层次中基类和子类的指针或引用类型转换：<上行转换：子类到基类>安全，<下行转换：基类到子类>无运行时动态类型检查，不安全；\n2. 用于基本类型之间的转换，如char2int，安全靠程序猿自己把握；\n3. void指针与其它类型指针之间的转换；\n**warning**： static-cast保留指针const, volatile, 等属性\n### reinterpret-cast作用\nKEY：通常为操作数的位模式提供较低层的重新解释；\n```c\nint i;\nchar* p = \"This is an example\";\ni = reinterpret_cast<int>(p);\n```\n### 其他\n1. dynamic-cast：“安全地向下转换”，即下行转换前会动态检查；\n2. const-cast: 强制消除对象的const属性；\n\n## 3. 智能指针shared_ptr循环引用问题\n### 循环引用问题\n智能指针shared_ptr采用引用计数的方式来记录指针，只有引用计数为1时才执行delete销毁对象。在双向链表使用时会出现循环引用问题，如例子所示：\n```c\n#include<iostream>\n#include<memory>\nusing namespace std;\nstruct Node\n{\n    int _value;\n    shared_ptr<Node> _next; // modify:weak_ptr<Node>\n    shared_ptr<Node> _prev; // modify:weak_ptr<Node>\n};\nint main()\n{\n    shared_ptr<Node> sp1(new Node);\n    shared_ptr<Node> sp2(new Node);\n    sp1->_next = sp2;\n    sp2->_prev = sp1;\n    cout<<sp1.use_count()<<endl; //引用计数-->2\n    cout << sp2.use_count() << endl;//引用计数-->2\n    system(\"pause\");\n    return 0;\n} //如何真正销毁sp1指向的Node？先销毁sp2---sp1---sp2------\n```\n### weak_ptr配合解决问题\n通过一个shared-ptr或weak-ptr对象构造，析构和构造不会引起引用指针的增加和减少。\n\n## 4. 对象生存周期\n在C++中存在四大类对象，分别为：\n1. **全局对象**：程序开始就构造，比main更早，程序结束main后析构；\n2. **局部对象**：对象诞生即构造，程序流程离开声明周期时，析构；\n3. **静态对象**：对象诞生即构造，程序结束main后析构，比全局对象早析构；\n4. **new产生的对象**：对象诞生即构造，delete即析构；\n\n### 代码演示\n```c\nGlobalClass gcls;  // 全局对象：其它文件通过关键字extern调用；\nstatic Demo1Class dcls1; // 静态全局对象：仅限本文件使用；\n// 全局对象：Global中存储；\n// 局部静态对象： Local Static中存储；\n\nint main(){\n  Demo2Class dcls2； // 局部对象：Stack栈中存储；\n  Demo3Class* dcls3 = new Demo3Class(); // new对象：Heap堆中存储；\n  delete dcls3;\n  return 0;\n}\n```\n\n\n\n\n\n## 参考\n* <http://www.yolinux.com/TUTORIALS/GDB-Commands.html>",[[1539170632498,["hsliu5@hsliu5",[[1,1943,"\n"]],[1938,1938],[1939,1939]]],[1539170647764,["hsliu5@hsliu5",[[1,1939,"## 5. delete基类指针"]],[1939,1939],[1955,1955]]],[1539170648263,["hsliu5@hsliu5",[[1,1960,"\n"]],[1955,1955],[1956,1956]]],[1539170657101,["hsliu5@hsliu5",[[1,1956,"###问题"]],[1956,1956],[1961,1961]]],[1539170658868,["hsliu5@hsliu5",[[1,1959," "]],[1959,1959],[1960,1960]]],[1539170661566,["hsliu5@hsliu5",[[1,1962,"描述："]],[1962,1962],[1965,1965]]],[1539170661817,["hsliu5@hsliu5",[[1,1970,"\n"]],[1965,1965],[1966,1966]]],[1539171322042,["hsliu5@hsliu5",[[1,1966,"类继承中，通过基类指针delete释放，会不会有内存泄漏？"]],[1966,1966],[1995,1995]]],[1539171322321,["hsliu5@hsliu5",[[1,2000,"\n"]],[1995,1995],[1996,1996]]],[1539171329540,["hsliu5@hsliu5",[[1,1996,"### 分析："]],[1996,1996],[2003,2003]]],[1539171329784,["hsliu5@hsliu5",[[1,2008,"\n"]],[2003,2003],[2004,2004]]],[1539171332004,["hsliu5@hsliu5",[[1,1996,"\n"]],[1995,1995],[1996,1996]]],[1539171415445,["hsliu5@hsliu5",[[1,2005,"根据“C++的继承规则和继承的实现原理机制”如果你不把基类的析构函数声明并定义为virtual,那么B类在释放的时候,没法做尾场清理的"]],[2005,2005],[2072,2072]]],[1539171418321,["hsliu5@hsliu5",[[-1,2026,"”"]],[2027,2027],[2026,2026]]],[1539171420008,["hsliu5@hsliu5",[[-1,2007,"“"]],[2008,2008],[2007,2007]]],[1539171424440,["hsliu5@hsliu5",[[1,2007,"**"],[1,2025,"**"]],[2007,2025],[2007,2029]]],[1539171433846,["hsliu5@hsliu5",[[1,2074,"。"]],[2074,2074],[2075,2075]]],[1539171437978,["hsliu5@hsliu5",[[-1,2057,"B"]],[2058,2058],[2057,2057]]],[1539171438854,["hsliu5@hsliu5",[[1,2057,"子"]],[2057,2057],[2058,2058]]],[1539171593878,["hsliu5@hsliu5",[[1,2080,"\n"]],[2075,2075],[2076,2076]]],[1539171604589,["hsliu5@hsliu5",[[1,2076,"在类继承机制中,构造函数和析构函数具有一种特别机制叫 “层链式调用通知”"]],[2076,2076],[2112,2112]]],[1539171606073,["hsliu5@hsliu5",[[-1,2102," "],[1,2103," "],[1,2112,"："]],[2112,2112],[2113,2113]]],[1539171610731,["hsliu5@hsliu5",[[1,2103,"**"],[1,2112,"**"]],[2103,2112],[2103,2116]]],[1539171643929,["hsliu5@hsliu5",[[1,2117,"在构造一个有类继承机制的类,比如上面的类B,那么会先调用A类的构造,A构造完成之后在调用B类的构造函数,达到\"由里向外\"通知调用的效果.那么释放一个有类继承机制的类,那么会调用B类的析构函数, 再调用A类的析构函数,达到\"由外向里\"通知通知的效果,那么为了达到这个这种“层链式调用通知”的效果，C++标准规定:基类的析构函数必须声明为virtual, 如果你不声明,那么\"层链式调用通知\"这样的机制是没法构建起来.从而就导致了基类的析构函数被调用了,而派生类的析构函数没有调用这个问题发生。"]],[2117,2117],[2362,2362]]]],null,"hsliu5@hsliu5"]]}